name: Solution CI

on:
  push:
    branches: ['**']
  pull_request:
    branches: ['**']

jobs:
  backend:
    name: Backend CI (NestJS)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    services:
      postgres:
        image: pgvector/pgvector:pg17
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10
      redis:
        image: bitnami/redis:latest
        env:
          REDIS_PASSWORD: redispass
          ALLOW_EMPTY_PASSWORD: no
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli -a redispass ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10

    defaults:
      run:
        working-directory: backend-coe/nestjs

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 8.15.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: pnpm
          cache-dependency-path: '**/pnpm-lock.yaml'

      - name: Install dependencies
        run: pnpm install --no-frozen-lockfile

      - name: Prepare CI env
        run: |
          cp .env.example .env
          cat >> .env <<'EOF'
          NODE_ENV=test
          PORT=3002
          CORS_ORIGINS=http://localhost:3000,http://localhost:3002
          REDIS_HOST=127.0.0.1
          REDIS_PORT=6379
          REDIS_PASSWORD=redispass
          REDIS_TLS_ENABLED=false
          POSTGRES_HOST=127.0.0.1
          POSTGRES_PORT=5432
          POSTGRES_DB=postgres
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=postgres
          DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:5432/postgres
          JWT_SECRET=ci-jwt-secret
          GRAFANA_URL=http://localhost:3001
          APP_LOGS_URL=http://localhost:9080/targets
          DEV_DOCS_URL=http://localhost:3005
          SERVICES_HEALTH_URL=http://localhost:3002/health/health-ui
          CI_HEALING_GITHUB_ENABLED=false
          CI_HEALING_WEBHOOK_SECRET=ci-webhook-secret
          CI_HEALING_CONTAINER_VALIDATION_REQUIRED=false
          CI_HEALING_CONTAINER_VALIDATE_WORKDIR=/home/runner/work/ci-fix-pilot/ci-fix-pilot/backend-coe/nestjs
          EOF

      - name: Type check
        run: pnpm type-check

      - name: Run database migration
        run: pnpm run db:migrate

  frontend:
    name: Frontend CI (Next.js)
    runs-on: ubuntu-latest
    timeout-minutes: 60

    defaults:
      run:
        working-directory: frontend-coe

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.17.1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: pnpm
          cache-dependency-path: '**/pnpm-lock.yaml'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Prepare frontend env
        run: |
          cp .env.example .env
          cat >> .env <<'EOF'
          NEXT_PUBLIC_APP_TITLE=PatchPilot Dashboard
          NEXT_PUBLIC_APP_NAME=PatchPilot Dashboard
          NEXT_PUBLIC_APP_DESCRIPTION=Patch Pilot self-healing CI command center
          NEXT_PUBLIC_APP_KEYWORDS=patch pilot,ci healing,devops,observability
          NEXT_PUBLIC_BACKEND_API_URL=http://localhost:3002/v1
          EOF

      - name: Type check
        run: pnpm type:check

      - name: Run Vitest suite
        run: pnpm test:run

  notify-ci-healing:
    name: Notify CI Healing
    runs-on: ubuntu-latest
    needs: [backend, frontend]
    if: ${{ always() }}

    steps:
      - name: Send CI failure webhook
        if: ${{ contains(fromJson('["failure","cancelled"]'), needs.backend.result) || contains(fromJson('["failure","cancelled"]'), needs.frontend.result) }}
        env:
          CI_HEALING_WEBHOOK_URL: ${{ secrets.CI_HEALING_WEBHOOK_URL }}
          CI_HEALING_WEBHOOK_SECRET: ${{ secrets.CI_HEALING_WEBHOOK_SECRET }}
          GITHUB_TOKEN: ${{ github.token }}
          REPOSITORY: ${{ github.repository }}
          BRANCH: ${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }}
          COMMIT_SHA: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || github.sha }}
          RUN_ID: ${{ github.run_id }}
          SERVER_URL: ${{ github.server_url }}
          BACKEND_RESULT: ${{ needs.backend.result }}
          FRONTEND_RESULT: ${{ needs.frontend.result }}
        run: |
          if [ -z "$CI_HEALING_WEBHOOK_URL" ]; then
            echo "CI_HEALING_WEBHOOK_URL secret is not configured. Skipping CI healing webhook."
            exit 0
          fi

          pipeline_url="${SERVER_URL}/${REPOSITORY}/actions/runs/${RUN_ID}"

          jobs_api="https://api.github.com/repos/${REPOSITORY}/actions/runs/${RUN_ID}/jobs?per_page=100"
          jobs_json=$(curl -sS \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${GITHUB_TOKEN}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$jobs_api")

          failed_jobs=$(echo "$jobs_json" | jq -c '[.jobs[]? | select(.conclusion == "failure") | {name: .name, conclusion: .conclusion, failed_steps: [.steps[]? | select(.conclusion == "failure") | .name]}]')
          failed_job_names=$(echo "$failed_jobs" | jq -r 'map(.name) | join(",")')

          error_log="Solution CI failed on branch=${BRANCH}; backend=${BACKEND_RESULT}; frontend=${FRONTEND_RESULT}; run=${pipeline_url}; failed_jobs=${failed_job_names}; failed_details=${failed_jobs}"

          payload=$(jq -n \
            --arg provider "github" \
            --arg repository "$REPOSITORY" \
            --arg branch "$BRANCH" \
            --arg commitSha "$COMMIT_SHA" \
            --arg pipelineUrl "$pipeline_url" \
            --arg errorType "workflow_failure" \
            --arg errorLog "$error_log" \
            '{provider:$provider,repository:$repository,branch:$branch,commitSha:$commitSha,pipelineUrl:$pipelineUrl,errorType:$errorType,errorLog:$errorLog}')

          if [ -n "$CI_HEALING_WEBHOOK_SECRET" ]; then
            signature=$(printf "%s:%s" "$CI_HEALING_WEBHOOK_SECRET" "$error_log" | shasum -a 256 | awk '{print $1}')
            http_code=$(curl -sS -o /tmp/ci-healing-webhook-response.txt -w "%{http_code}" -X POST "$CI_HEALING_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              -H "x-ci-signature: ${signature}" \
              --data "$payload")
          else
            http_code=$(curl -sS -o /tmp/ci-healing-webhook-response.txt -w "%{http_code}" -X POST "$CI_HEALING_WEBHOOK_URL" \
              -H "Content-Type: application/json" \
              --data "$payload")
          fi

          if [ "$http_code" -lt 200 ] || [ "$http_code" -ge 300 ]; then
            echo "CI healing webhook failed with HTTP $http_code"
            cat /tmp/ci-healing-webhook-response.txt || true
            exit 1
          fi

      - name: Send Slack failure notification
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          REPOSITORY: ${{ github.repository }}
          BRANCH: ${{ github.event_name == 'pull_request' && github.head_ref || github.ref_name }}
          RUN_ID: ${{ github.run_id }}
          SERVER_URL: ${{ github.server_url }}
          BACKEND_RESULT: ${{ needs.backend.result }}
          FRONTEND_RESULT: ${{ needs.frontend.result }}
        run: |
          if [ -z "$SLACK_WEBHOOK_URL" ]; then
            echo "SLACK_WEBHOOK_URL secret is not configured. Skipping Slack notification."
            exit 0
          fi

          pipeline_url="${SERVER_URL}/${REPOSITORY}/actions/runs/${RUN_ID}"
          if [ "$BACKEND_RESULT" = "success" ] && [ "$FRONTEND_RESULT" = "success" ]; then
            title="âœ… Solution CI passed"
            status_emoji=":white_check_mark:"
          else
            title="ðŸš¨ Solution CI failure detected"
            status_emoji=":rotating_light:"
          fi

          summary="Repository: ${REPOSITORY} | Branch: ${BRANCH} | Backend: ${BACKEND_RESULT} | Frontend: ${FRONTEND_RESULT}"

          slack_payload=$(jq -n \
            --arg text "$title" \
            --arg summary "$summary" \
            --arg run_url "$pipeline_url" \
            --arg backend "$BACKEND_RESULT" \
            --arg frontend "$FRONTEND_RESULT" \
            --arg status_emoji "$status_emoji" \
            '{
              text: $text,
              blocks: [
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: "*" + $status_emoji + " " + $text + "*"
                  }
                },
                {
                  type: "section",
                  fields: [
                    { type: "mrkdwn", text: "*Backend*\n" + $backend },
                    { type: "mrkdwn", text: "*Frontend*\n" + $frontend }
                  ]
                },
                {
                  type: "section",
                  text: {
                    type: "mrkdwn",
                    text: "*Details*\n" + $summary
                  }
                },
                {
                  type: "actions",
                  elements: [
                    {
                      type: "button",
                      text: { type: "plain_text", text: "Open GitHub Run" },
                      url: $run_url
                    }
                  ]
                }
              ]
            }')

          slack_http_code=$(curl -sS -o /tmp/slack-webhook-response.txt -w "%{http_code}" -X POST "$SLACK_WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            --data "$slack_payload")

          if [ "$slack_http_code" -lt 200 ] || [ "$slack_http_code" -ge 300 ]; then
            echo "Slack webhook failed with HTTP $slack_http_code"
            cat /tmp/slack-webhook-response.txt || true
            exit 1
          fi
